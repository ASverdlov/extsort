# Внешняя сортировка

## Предположения
1. Окончанием строчек является символ `\n`.

## TODO
1. Адаптировать библиотеку для файлов >1GB. Проблемы: например,
`fseek()`, использующийся в `file.cpp` не позволяет изменять позицию в файле
свыше 1GB от начала файла, для позиций файла используются `int`.

## Сборка
```bash
git submodule update --init --recursive
mkdir build && cd build
cmake .. && make
```

Бинарник положится по пути: `./build/src/externalsort`

## Запуск функционального теста + Сборка
```bash
./tools/build_and_compare_with_sort.sh
```

## Терминология
Алгоритм оперирует одним видом объектов: `chunk`-ом.
`chunk` -- это полуотрезок
позиций в определенном файле.

## Опции запуска

1. `--input, -i` - путь к входному файлу
2. `--output, -o` - путь к выходному (отсортированному) файлу
3. `--chunksize, -c` - минимальный размер кусков, после начального разделения файла
4. `--merge-concurrency, -m` - указывает сколько параллельных кусков могут
сливаться во время стадии `merge-stage` (см. ниже)

## Алгоритм
В основе алгоритма лежат 3 операции: `divide()`, `sort()` и `merge()`.
1. `divide(chunk, chunksize)` разделяет chunk на последовательные chunk-и
размера `chunksize`.
2. `sort(chunk, out_chunk)` сортирует `chunk` и записывает в `out_chunk`
(возможно находящийся в другом файле).
3. `merge(chunks, out_chunk)` сливает массив отсортированных `chunk`-ов
(`chunks`) и записывает в `out_chunk`.

Сортировка больших файлов реализуется в несколько стадий:
### `1.sort-stage`

Исходный файл делится на `chunk`-и размера `--chunksize`.
Каждый `chunk` загружается в память, отправляется на сортировку (обычную в памяти),
и пишется обратно на диск (во временный файл).

В итоге имеем отсортированные `chunk`-и.

### `2.merge-stage`

Стадия слияний отсортированных `chunk`-ов.
Обозначим `M` := `--merge-concurrency` (сколько одновременных чанков могут
сливаться в `merge()`).

Процедура слияния:
1. Берем первые `M` `chunk`-ов.
2. Создадим `M` указателями по каждому `chunk`-у.
3. Реализуем примитивный `M-way Merge`.
4. Передвигаемся к следующим `chunk`-ам. Повторяем (2) пока не дойдем до конца.

Если после исполнения процедуры слияния количество `chunk`-ов равно 1,
программа завершена, иначе процедура повторяется.

## Оценка
Асимптотически алгоритм работает за `O(n*logn)` времени, где n -- размер файла.
На практике, важнее уменьшить количество промахов кэшей (L1, L2, L3).

Алгоритмически решение не зависит от размера входного файла.
Потребляемое количество памяти: O(`--merge-concurrency`).

Недостатком реализации является высокое число потребляемых файловых
дескрипторов (~ `--merge-concurrency`).

Дополнительно требуется 2 временных файла совпадающих с исходным по размеру.
Можно обойтись 1 временным файлом, если использовать в качестве 2го -
`--output` файл.

